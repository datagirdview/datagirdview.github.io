---
layout: page
title: Leetcode解题思路
---

## 26. 删除排序数组中的重复项
双指针，如果重复就和前面相邻的互换。
```python
# 给定 nums = [0,0,1,1,1,2,2,3,3,4],
# 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
# 你不需要考虑数组中超出新长度后面的元素。

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        n, i = len(nums), 0
        if not n:
            return n
        for j in range(1,n):
            if nums[i] != nums[j]:
                i = i + 1
                nums[i] = nums[j]
        return i + 1   
```

## 973. 最接近原点的 K 个点
堆算法，Python一行。
```python
# 输入：points = [[3,3],[5,-1],[-2,4]], K = 2
# 输出：[[3,3],[-2,4]]

class Solution:
    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:
        return heapq.nsmallest(K, points, key=lambda x: sqrt(x[0]*x[0] + x[1]*x[1]))
```

## 56. 合并区间
简单的合并区间题，可以作为其他题目的工具函数。比如以下。
```python
class Solution:
    def merge(self, intervals):
        intervals.sort(key=lambda x: x[0])
        merged = []
        for interval in intervals:
            if not merged or merged[-1][1] < interval[0]:
                merged.append(interval)
            else:
                merged[-1][1] = max(merged[-1][1], interval[1])
        return merged
```

## 763. 划分字母区间
首先找到每个字母的开始和结束的区间，然后用上一问的函数，直接解决。
```python
# 输入: S = "ababcbacadefegdehijhklij"
# 输出: [9,7,8]
# 解释:
# 划分结果为 "ababcbaca", "defegde", "hijhklij"。
# 每个字母最多出现在一个片段中。
# 像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。

class Solution:
    def partitionLabels(self, S: str) -> List[int]:
        n, indexDict = len(S), {}, 
        for i in range(n):
            if not indexDict.get(S[i]):
                indexDict[S[i]] = [-1, -1]
                indexDict[S[i]][0], indexDict[S[i]][1] = i, i
            else:
                indexDict[S[i]][1] = i
        result = self.merge(list(indexDict.values()))
        return [x[1]-x[0] + 1 for x in result]

    def merge(self, intervals):
        intervals.sort(key=lambda x: x[0])
        merged = []
        for interval in intervals:
            if not merged or merged[-1][1] < interval[0]:
                merged.append(interval)
            else:
                merged[-1][1] = max(merged[-1][1], interval[1])
        return merged
```


## 剑指 Offer 12. 矩阵中的路径
```python
# 回溯的深度优先遍历，用/表示已经访问，word的索引k == len(board) - 1时成功返回，其他情况下都是False
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        def dfs(i, j, k):
            if not 0 <= i < len(board) 
                or not 0 <= j < len(board[0]) 
                or board[i][j] != word[k]:
                return False
            if k == len(word) - 1:return True
            tmp, board[i][j] = board[i][j], "/"
            res = dfs(i + 1, j, k + 1) 
                or dfs(i, j + 1, k + 1) 
                or dfs(i - 1, j ,k + 1) 
                or dfs(i, j - 1, k + 1)
            board[i][j] = tmp
            return res
        
        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(i, j, 0): return True
        return False
```

## 剑指 Offer 13. 机器人的运动范围
visited存储已经访问过的节点，核心数学在于:
![T7lZXRxI6BzQifY](https://i.loli.net/2020/08/06/T7lZXRxI6BzQifY.png)
```python 
class Solution:
    def movingCount(self, m: int, n: int, k: int) -> int:
        # dfs 解决
        def dfs(i, j, p, q):
            if i >= m or j >= n or p + q > k or (i, j) in visited:return 0
            visited.add((i, j))
            return 1 + 
                dfs(i + 1, j, p + 1 if (i + 1) % 10 else p - 8, q) + 
                dfs(i, j + 1, p, q + 1 if (j + 1) % 10 else q - 8)
        
        visited = set()
        return dfs(0,0,0,0)

        # bfs 解决
        queue, visited = [(0,0,0,0)], set()
        while queue:
            i, j, p, q = queue.pop()
            if i >= m or j >= n or p + q > k or (i, j) in visited:continue
            visited.add((i, j))
            queue.append((i+1, j, p + 1 if (i + 1) % 10 else p - 8, q))
            queue.append((i, j + 1, p, q + 1 if (j + 1) % 10 else q - 8))
        return len(visited)
```
## 剑指 Offer 14- I. 剪绳子
数学问题，分为3和2时最大。溢出的时候不能用dp。
```python
class Solution:
    def cuttingRope(self, n: int) -> int:
        if n <=3:return n-1
        a, b = n//3, n%3
        if b == 0:return int(math.pow(3, a))
        if b == 1:return int(math.pow(3, a-1) * 4)
        return int(math.pow(3, a) * 2)

    def cuttingRope(self, n: int) -> int:
        if n <= 3:return n - 1
        res = 1
        while n > 4:
            n -= 3
            res *= 3
        return res*n
```

## 剑指 Offer 26. 树的子结构
递归，先找到中B的起始节点，再递归比较子树。
```python
class Solution:
    def isSubStructure(self, A: TreeNode, B: TreeNode) -> bool:
        def recu(A, B):
            if not B:return True
            if not A or A.val != B.val:return False
            return recu(A.left, B.left) and recu(A.right, B.right)
        
        return bool(A and B) and (recu(A,B) or self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B))
```

## 剑指 Offer 31. 栈的压入、弹出序列
辅助栈，i值自增
```python
class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        stack, i = [], 0
        for num in pushed:
            stack.append(num)
            while stack and stack[-1] == popped[i]:
                stack.pop()
                i += 1
        return not stack
```

## 剑指 Offer 33. 二叉搜索树的后序遍历序列
递归解法，在给定的一段数组中分出左子树和右子树，递归比较。
```python
class Solution:
    def verifyPostorder(self, postorder: List[int]) -> bool:
        def recu(i, j):
            if i >= j:return True
            p = i
            while postorder[p] < postorder[j]:p += 1
            m = p
            while postorder[p] > postorder[j]:p += 1
            return p == j and recu(i, m - 1) and recu(m, j - 1)

        return recu(0, len(postorder) - 1)
        
```

## 剑指 Offer 34. 二叉树中和为某一值的路径
先序遍历。存储扣掉的每一次根节点的值。
```python
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:
        res, path = [], []
        def preorder(root, tar):
            if not root:return
            path.append(root.val)
            tar = tar - root.val
            if tar == 0 and not root.left and not root.right:
                res.append(list(path))
            preorder(root.left, tar)
            preorder(root.right,tar)
            path.pop()
         
        preorder(root, sum)
        return res
```