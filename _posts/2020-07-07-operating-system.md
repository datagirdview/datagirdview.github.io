---
layout: page
title: 操作系统相关
---

### 什么是系统调用？
用于用户程序从用户态转换为内核态。（使用陷阱而不是指令实现系统调用）

内核态中，操作系统对于所有的硬件具有完全的访问权，可以运行任何指令。

用户态中，只能使用机器指令中的一个子集，不能运行I/O等操作指令。

如果一个程序正在用户态运行一个用户程序，当他需要一个系统服务的时候，他就需要切换到内核态去执行这个过程调用。这个过程就是系统调用。

### 什么是进程？什么是线程？
进程是对正在运行程序的一种抽象，进程有独立的地址空间。

线程是划分进程的更小单位，同一个进程内的线程共享线程的堆和资源。

### 进程和线程有什么区别
* 线程共享资源，进程独立运行
* 进程更加的轻量，更快，开销更小
* 多CPU对于线程有益，真正实现并行

### 进程有哪几种状态？
创建、就绪、阻塞、运行、终止

### 什么是竞争条件？
两个或者多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序。

### 什么是临界区？
对于共享内存进行访问的程序片段。

如果能够将两个进程不再同时处于临界区时就能避免竞争条件。


### 进程通信是怎么实现的？
* 匿名管道：半双工、只支持亲子关系、本质上是内核缓冲区的FIFO、无格式字节流。当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开
* 有名管道：存在于文件系统中，通过访问文件来通讯，FIFO
* 信号：用于通知接受进程有某种事件发生，进程将一直保有这个信号直到执行
* 消息队列：存在内核的消息链表中，包括Posix消息队列system V消息队列。有权限的进程可读可写可查询，不需要读等待。
* 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式，需要同步机制
* 信号量：同步与互斥
* 套接字：本地/网络通信，更具一般性

### 线程通信是怎么实现的？
线程间的通信目的主要是用于线程同步。
1. 锁机制：互斥锁、条件变量、读写锁和自旋锁。
  **互斥锁**确保同一时间只能有一个线程访问共享资源。
  **读写锁**当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。
  **条件变量**可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
  **自旋锁**上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 
2. 信号量：和进程类似
3. 信号：和进程类似

### 僵死进程和孤儿进程的区别？
**孤儿进程**：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

**僵死进程**：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。


#### 信号的处理流程是怎么样的？
* 进程产生信号，设置传给的进程pid，传给操作系统内核
* 根据接受者判断，阻塞先保留，运行直接发，退出就丢弃
* 收到信号，终止代码执行，保护上下文，执行中断，然后回到中断

#### Linux中三种信号量？
* POSIX有名信号量
* POSIX基于内存的信号量
* System V信号量

#### 什么是互斥？
某一资源某一时刻只允许有一个进程访问，具有唯一性和排他性，无法限制访问者的访问顺序

#### 什么是同步？
在互斥的基础上实现有序访问

### 进程如何获取一个共享资源？
1. 创建信号量
2. P操作：等待一个信号量，值等于0就阻塞，大于0就减1（用掉一个保存的唤醒信号）
3. V操作：挂出一个信号量，信号量减1

### 进程的调度算法有哪些？
* 先来先服务（FCFS）：就绪队列中最先进入的，执行到完成或者阻塞
* 短作业优先（SJF）：就绪中选择预估最快能完成的
* 时间片轮转（RR）：每个都被分配一定的时间
* 优先级调度：根据内存要求、时间要求、资源分配要求分配优先级
* 多级反馈队列：既能使短作业完成，又能让优先级高的得到响应


### 什么是死锁？为什么会产生死锁？有什么解决方案？
两个或多个进程之间相互阻塞，与不可抢占的资源相关

产生死锁的条件：
* 互斥条件
* 循环等待
* 不可剥夺
* 请求保持

解决方案：
* 死锁预防：破坏四个条件中的一个
* 死锁避免：银行家算法
* 死锁检测
* 死锁解除：资源剥夺、撤销进程

### 内存管理机制有哪些？
连续分配 - 块式
离散分配 - 页式、段式、段页式

### 分页和分段有什么区别？
相同：提高内存的利用率；离散存储但内部连续
不同：页大小固定，段大小不固定；分页好管理，分段好理解

### 什么是快表？
解决了CPU中MMU将虚拟地址到物理地址转换速度的问题，是地址缓冲表。
流程：
1. 根据虚拟地址中的页号查询快表
2. 如果查到就直接读取物理地址
3. 如果没有就访问内存中的页表，得到物理地址，并将表映射关系加到快表当中
4. 表满时，使用淘汰策略淘汰其中的一页

### 什么是虚拟内存？什么是虚拟地址空间？
为了让硬件能够运行需要大内存的程序，将程序分成多个页面，动态的换入换出。

虚拟内存时对于主存的抽象，且只有在离散内存分配基础上才能够实现虚拟内存。

用页面的调入调出时间换取更大的空间。

### 虚拟内存有什么好处？
* 扩展可用空间
* 每个进程拥有逻辑上连续的内存空间
* 保护进程的独立资源

### 缺页中断的过程是怎么样的？
1. MMU查询页表时发现相应虚拟地址没有被映射
2. 在主存上没有相关页
3. 调页调段
4. 继续执行


### 什么是多级页表？
解决大内存页表问题。

时间换空间，避免所有页表放在内存中

### 有哪些页面置换算法？
页面置换算法是在内存空间不够用的情况下，选择淘汰的页面的策略。
* OPT：最佳页面置换算法：不可能实现
* FIFO：先进先出
* NRU：最近未使用：随机从类编号最小的非空类中挑选一个页面淘汰
* clock：时钟，直到找到第一个R位为0的页面，将他淘汰
* LRU：最近最少使用：维护一个链表代价很高，或者在页表中加一项（需要硬件支持）
* NFU：最少使用：每次时钟中断就扫描所有内存页面，加R的和算频数（LRU的粗略估计）
* 老化算法：维护一个计数器，记录之前活跃的一张表。缺页中断时置换值最小的表。
![tEwR6rVL437TQBl](https://i.loli.net/2020/07/08/tEwR6rVL437TQBl.png)

### 什么是局部性原理？
表现在时间局部性和空间局部性两个方面。

时间局部性：指令可能被再次执行，数据可能被再次访问（循环操作）

空间局部性：同一段时间内访问的地址可能在空间上聚集

### Python的线程调度？

### 有哪几种I/O模型？
* 阻塞I/O：使用系统调用，并一直阻塞直到内核将数据准备好，之后再由内核缓冲区复制到用户态，在等待内核准备的这段时间什么也干不了。除非特别指明，几乎所有I/O都是阻塞的。
* 非阻塞I/O：非阻塞式IO的轮询会耗费大量cpu，通常在专门提供某一功能的系统中才会使用。需要用户进程不断询问内核数据有没有准备好。
* I/O多路复用：select/poll/epoll，类似于非阻塞，只不过轮询不是由用户线程去执行，而是由内核去轮询，内核监听程序监听到数据准备好后，调用内核函数复制数据到用户态
* 信号驱动I/O
* 异步I/O：发起操作立即返回，由内核发送信号给用户进程通知完成。

![gysNbfd2ZzjwlCR](https://i.loli.net/2020/07/08/gysNbfd2ZzjwlCR.png)

### 什么是多路复用？
* select：线性扫描所有监听的文件描述符，不管他们是不是活跃的。有最大数量限制（32位系统1024，64位系统2048）
* poll：同select，不过数据结构不同，需要分配一个pollfd结构数组，维护在内核中。它没有大小限制，不过需要很多复制操作
* epoll：用于代替poll和select，没有大小限制。使用一个文件描述符管理多个文件描述符，使用红黑树存储。同时用事件驱动代替了轮询。epoll_ctl中注册的文件描述符在事件触发的时候会通过回调机制激活该文件描述符。epoll_wait便会收到通知。最后，epoll还采用了mmap虚拟内存映射技术减少用户态和内核态数据传输的开销

### linux如何实现共享内存？
共享内存是通过把同一块内存分别映射到不同的进程空间中实现进程间通信。当多个进程同时对同一内存进行读写操作时会破坏该内存的内容，所以需要实现同步与互斥机制。

Linux的2.2.x内核支持多种共享内存方式，如mmap()系统调用，Posix共享内存，以及系统V共享内存。

系统调用mmap()通过映射一个普通文件实现共享内存。

系统V则是通过映射特殊文件系统shm中的文件实现进程间的共享内存通信。也就是说，每个共享内存区域对应特殊文件系统shm中的一个文件（这是通过shmid_kernel结构联系起来的）

mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。
注：实际上，mmap()系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或系统V的共享内存IPC则纯粹用于共享目的，当然mmap()实现共享内存也是其主要应用之一。



因为用来访问内存以得到指令或数据的时间要比执行指令花费的时间长的多，因此，所有的CPU内部都有一些用来保存关键字变量和临时数据的寄存器。

通用寄存器：保存变量和临时结果
程序计数器：程序员可见，保存将要读取的下一条指令的内存地址
堆栈指针：程序员可见。指向内存当中当前栈的顶端。栈当中包含了每个执行过程的栈帧。一个过程的栈帧中包含输入参数、局部变量和没有保存在寄存器中的临时变量。
程序状态字寄存器：包含条件码位、CPU优先级、CPU模式（内核态和用户态）和其他控制位。


计算机是如何启动的？
“在计算机启动时，BIOS开始运行。它首先检查所安装的RAM数量，键盘和其他基本设备是否已安装并正常响应。接着，它开始扫描ISA和PCI总线并找出连在上面的所有设备。其中有些设备是典型的遗留设备（即在即插即用发明之前设计的），并且有固定的中断级别和I/O地址（也许能用在I/O卡上的开关和跳接器设置，但是不能被操作系统修改）。这些设备被记录下来。即插即用设备也被记录下来。如果现有的设备和系统上一次启动时的设备不同，则配置新的设备。

然后，BIOS通过尝试存储在CMOS存储器中的设备清单决定启动设备。用户可以在系统刚启动之后进入一个BIOS配置程序，对设备清单进行修改。典型地，如果存在软盘，则系统试图从软盘启动。如果失败则试用CD-ROM，看看是否有可启动CD-ROM存在。如果软盘和CD-ROM都没有，系统从硬盘启动。“启动设备上的第一个扇区被读入内存并执行。这个扇面中包含一个对保存在启动扇面末尾的分区表检查的程序，以确定哪个分区是活动的。然后，从该分区读入第二个启动装载模块。来自活动分区的这个装载模块被读入操作系统，并启动之。

然后，操作系统询问BIOS，以获得配置信息。对于每种设备，系统检查对应的设备驱动程序是否存在。如果没有，系统要求用户插入含有该设备驱动程序的CD-ROM（由设备供应商提供）。一旦有了全部的设备驱动程序，操作系统就将它们调入内核。然后初始化有关表格，创建需要的任何背景进程，并在每个终端上启动登录程序或GUI。”

#### 每个进程中的内容
地址空间、全局变量、打开文件、子进程、即将发生的定时器、信号与信号处理程序、账户信息

#### 每个线程中的内容
程序计数器、寄存器、堆栈、状态


