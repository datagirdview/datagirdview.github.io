---
layout: page
title: 高性能MySQL
---
[TOC]

## 架构
他的架构设计把**查询处理以及系统任务**和**数据的存储和提取**相分离。

![架构图](https://i.loli.net/2020/05/25/r4DdlefLk1gFtqY.png)

### 并发控制
通过创建锁，来控制并发的资源占用问题。
#### 读写锁
读锁，也叫共享锁，互相不阻塞。
写锁，也叫排他锁，会阻塞其他的读锁和写锁。
#### 锁粒度
通过区分加锁的数据量，来提升系统的并发量。但是锁操作都会增加系统的开销。所以要在安全性和锁开销之间寻求一个平衡。
##### 两种重要的锁策略
表锁：开销最小的策略。一般采用mysql自己实现的表锁而忽略存储引擎的锁机制。
行锁：最大程度的并发处理，伴随最大的开销。且只在存储引擎中实现。

### 事务
四大特性：
* 原子性：要么全部成功，要么全部失败
* 一致性：从一个一致性转换成另一种一致性
* 隔离性：所做的改变在最终提交之前，对于其他事务来说是不可见的
* 持久性：事务提交之后改动不会丢失

#### 四种隔离级别
较低级别的隔离通常可以执行更高的并发，开销也更低。
* read uncommitted（未提交读）：很少使用，问题很多
* read uncommitted（提交读/不可重复读）：大多数数据库系统的默认级别（Mysql不是），其他事务执行两次相同的读可能得到不一样的结果。
* repeatable read（可重复读）：MySQL默认隔离级别。解决脏读问题，会有幻行的问题（多了一行）。Mysql已经解决了这一问题。
* serializable（串行）：强制事务串行执行。对读取的所有行都加锁。

避免不可重复读锁行就行
避免幻读锁表就行

#### 多版本并发控制MVCC
行级锁的变种，很多情况下避免了加锁操作，开销更低。

InnoDB的MVCC通过在每一行后面保存两个隐藏的列来实现，一个是行的创建时间，一个是行的过期时间（版本号）

### 引擎
#### InnoDB
数据存储在表空间中。表是基于聚簇索引建立的。
#### MyISAM
不支持事务和行级锁，崩溃后无法恢复。

MYD和MYI文件存储，分别存储数据文件和索引文件。


## 服务器性能剖析
性能优化并不是降低cpu利用率、也不是提升每秒查询量
### 应用程序的性能剖析
对任何需要消耗时间的任务都可以进行性能剖析。性能瓶颈可能有很多的影响因素：
* 外部资源。调用了外部的服务或者搜索引擎
* 应用处理大量的数据，分析一个超大规模的XML文件
* 在循环中执行昂贵的操作，滥用正则表达式
* 使用了低效的算法

性能剖析会导致服务器变慢，但是为了定位一些性能平静下来，还是值得的，可以通过采样的方式发现严重问题。
### 关于MySQL的查询
#### 整体负载
**慢查询日志**
记录执行时间超过某一值的语句。是开销最低、精度最高的测量查询时间的工具。
分析慢查询日志时，先使用pt-query-digest生成一个剖析报告，它能够提供日志的一个整体的概览，接下来再去定为精确所在之处也不迟。
![pt-query-digest](https://i.loli.net/2020/05/28/eIOhlKNU8JgpwX5.png)

#### 单条查询优化
* `show profile`：服务器上执行的所有语句都会测量器耗费的时间
* `show status`：返回全局计数器，也有某个会话级别的计数器。显示某些活动的频繁程度。
* 慢查询日志
* `performance schema`：5.5之后会变得很强大，待考证。

#### 如何诊断间歇性问题
使用`show global status`/`show process list`/`查询日志`确定是单条查询还是服务器问题

## schema与数据类型的优化
### 优化的数据类型
#### 原则
* 更小的通常更好，但要确保没有低估值的范围
* 简单就好，整型比字符操作代价更低
* 尽量避免NULL值。但通常把可为NULL的列改为NOT NULL对性能提升不是很大，如果计划对该列上建立索引，那么最好不要设置NULL

在选择数据类型是，第一步确定合适的大类型（数字、字符串、时间等），然后选择具体的类型。

#### 整数类型
`TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`、`BIGINT`，也可以无符号，将上限提升一倍

分别是8,16,24,32,64为存储空间 $-2^{N-1}\leq x \leq 2^{N-1}$

#### 实数类型

`DECIMAL`类型可以指定精度，对于`DECIMAL`列可以指定小数点前后所允许的最大位数。`DECIMAL`(18,9)小数点两边各存储9个数字，一共使用9个字节，一个小数点，4个整数部分、4个小数部分。

`FLOAT`使用4个字节，`DOUBLE`使用8个字节。MySQL使用`DOUBLE`作为内部浮点计算的类型。

#### 字符串类型

`VARCHAR`、`CHAR`实现形式与数据库引擎有关。

`VARCHAR`用于存储可变长字符串，比定长更加节省空间，但update时可能需要做额外开销。`VARCHAR`需要使用1-2个额外字节记录字符的长度。

合适的情况：
* 列最大长度比平均长度大很多
* 列更新很少
* 使用了复杂的字符集UTF-8

`CHAR`适合存储很短的字符串，或者所有值接近同一个长度，并且删除所有的末尾空格。例如MD5值，因为定长的MD5值不容易产生碎片。

`BLOB`和`TEXT`，BLOB二进制、TEXT字符形式，BLOB和SMALLBLOB同义词，TEXT和SMALLTEXT同义词。当他们太大时，InnoDB会使用专门的存储区域来存储，在行内需要1-4个字节存储一个指针。

需要尽量避免使用这两种类型。

**使用枚举代替字符串**
* 存储非常紧凑，会根据列表值的数量压缩到1-2个字节中。将每个值在列表中的位置保存为整数，并且在frm的文件中保存数字-字符串映射关系的查找表。
* 内部排序按照枚举的存储顺序排序的。
* 字符列表是固定的，添加、删除都是需要使用`ALTER TABLE`的

#### 日期和时间类型

`DATETIME`：1001-9999精度为秒，YYYYMMDDHHMMSS

`TIMESTAMP`：1970-2038 秒数，比datetime的效率更高。

#### 位数据类型
`BIT`：存储一个或者多个True False的值（0，1的字符串）

如果存储一个`b'00111001'`的值，数字上下文的场景中，会导致返回57，而不是ascii码为57的字符‘9’，因此要谨慎使用BIT。
![屏幕快照 2020-05-30 下午4.59.25.png](https://i.loli.net/2020/05/30/l9qKUinm5ypakY6.png)

`SET`：一种代价相对来说较高的表示位的形式，一些列打包的bit位。但是改变列的代价相对较高，且无法在set列上通过索引查找。

#### 如何选定标识符

整数通常是最好的选择 很快，并且可以使用auto_increment

enum和set糟糕的选择

尽量避免使用字符作为标识列，当使用uuid值时，最好把“-”删除，按照数字的方式存储，还是不如递增的整数好用

一些ORM系统是常见的性能噩梦，存储的类型比较任意。

### schema设计中的陷阱

* 太多的列：行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的
* 太多的关联：单个查询最好在12个表以内做关联
* 全能的枚举：0，1，2，3
* 变相的枚举
* 非此发明的NULL：不要刻意不用NULL

### 范式和反范式

范式化的数据库中，每个事实数据都会出现并且仅出现一次。
反范式化的数据库中，信息是冗余的可能存储在多个地方。

#### 范式的优点和缺点
优点：

* 更新操作比反范式操作快
* 当数据较好的范式化时，就只有很少或者没有重复数据，所以执行操作会更快
* 范式化的表通常更小，可以更好的放在内存里，执行操作会更快
* 很少有多余的数据意味着检索列表时更少需要DISTINCT或者GROUP BY
  
缺点：
通常需要关联，代价昂贵，使得一些索引策略无效

#### 反范式的优点和缺点
优点：
* 避免关联
* 进行更有效的索引策略

#### 实际应用中经常是混用范式化和反范式化
最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列，可以使用触发器更新缓存值。

### 缓存表和汇总表
缓存表表示存储哪些可以比较简答的从schema中其他表中获取数据的表（获取的速度比较慢）
汇总表表示的是使用GROUP BY语句聚合数据的表

有时候可以在缓存表上使用别的数据库引擎，例如支持更小索引占用空间、全文搜索的MyISAM。

使用缓存表和汇总表时，要决定是定时维护还是定期重建数据。

重建汇总表和缓存表时，通常需要保证数据在操作时仍然可用，通过‘影子表’实现。

更快的读，更慢的写。

### 如何加快ALTER TABLE
有一些情况不需要重建表
* 移除一个列的AUTO_INCREMENT
* 增加、删除和更改enum set常量

技术是为想要的表结构创建一个新的.frm：
1. 创建一张有相同结构的空表，进行所需要的修改
2. FLUSH TABLES WITH READ LOCK，关闭所有表。
3. 交换frm文件
4. UNLOCK TABLES


## 创建高性能的索引
### 什么是索引
#### B-tree索引
* 支持全值匹配
* 匹配最左前缀
* 匹配列前缀
* 匹配范围值
* 匹配一列到另一列
* 只访问索引
#### 哈希索引
只有memory引擎支持hash索引
只能进行全值匹配
#### 空间数据索引
#### 全文索引
### 索引好在哪里
* 减少服务器需要扫描的数据量
* 帮助服务器避免排序和临时表
* 将随机IO变为顺序IO
  
注：当表比较小时，全表查找比索引可能更快，中大型表用索引，大型表建立索引开销比较大，可以采用分区索引。

### 高性能的索引策略
#### 选择独立的列
要求查询时，索引列既不能是表达式的一部分，也不能是函数的参数
#### 前缀索引
索引的选择性：不重复的索引值和数据表记录总数的比值，$[\frac{1}{n},n]$。
能够是索引更小更快的有效办法，无法进行orderby和groupby
#### 选择合适的索引策略
如果一个索引对应的数据条数更小，那么它应该放在更前面
#### 聚簇索引
数据放在叶子结点，索引在树节点上
InnoDB通过主键聚集数据，如果没有主键，则使用非空索引，如果没有索引，隐式定义一个主键作为聚簇索引。
#### 覆盖索引
索引中已经包含要查询的字段的值
如果视同like来做匹配，那么就不能进行覆盖索引
#### 使用索引扫描来做排序
* 只有当索引的列顺序和orderby的子句顺序完全一致并且所有列的排序方向都一样时，MySQL才能够使用索引来对结果做排序
* 关联操作时，只有子句引用字段全部为第一个表时，才能够使用索引做排序

满足最左前缀的要求
#### 压缩索引
MyISAM使用前缀压缩来减少索引的大小，从而让更多索引可以放入内存中。不过某些操作会更慢
```
ex:perform,performance
output:7,ance
```

#### 冗余和重复索引
mysql的唯一约束和主键都是索引实现的。多个在同一个字段上，就是重复索引。
`(A,B)`和`(A)`，后者就是冗余索引，`(B,A)`不是冗余索引

#### 未使用索引
建议删除

#### 索引和锁
Inno只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，减少锁的数量。

### 维护索引和表
通过`CHECK TABLE`来检查是否发生了表损坏，`REPAIRE TABLE`来修复表。如果不可以，可以使用`ALTER TABLE innodb_tb1 ENGINE=INNODB;`

## 查询性能优化
查询优化、索引优化、库表结构必须要齐头并进
### 查询速度慢的原因
查询的生命周期：从客户端、到服务器，服务器解析、生成执行计划，执行、返回结果给客户端。执行是生命周期中最重要的阶段，也是最耗时的步骤。
在执行中，查询需要在不同的地方花费时间，包括网络、cpu计算、生成统计信息和执行计划、锁等待操作等。

### 访问的数据太多：优化数据访问
分析是否试一下的两个问题：

#### 是不是在检索超多数据，访问了太多的行，或者是列
* 查询了不需要的数据，比如客户端只需要前十行
* 多标关联时返回了全部列
* 总是取出全部列（一些DBA是禁止`select * `写法的）
* 重复查询相同的数据


#### 是不是在扫描额外的记录
* 估计响应时间（我不太会）
* 查看扫描的行数。能够说明该查询的效率
* 查看访问类型。`EXPLAIN`语句中的`type`能够反映访问类型，访问类型的种类为全表扫描、索引扫描、范围扫描、唯一索引扫描、常数引用等。速度由快到慢。

一般MySQL能够使用如下方式应用WHERE条件（由好到坏）：
* 在索引中使用WHERE条件来过滤不匹配的记录，在存储引擎层完成。
* 使用索引覆盖扫描（Extra：Using Index）来返回记录，从索引中过滤不需要的记录并返回命中的结果，无需回表查询。
* 从数据表中返回数据，过滤不满足条件的记录。

一些技巧：
* 使用索引覆盖扫描，将需要的列都放在索引中
* 改变库表结构。例如使用单独的汇总表
* 充血复杂查询，让MySQL优化器能够以更加优化的方式执行这个查询

### 重构查询的方式
一个重要的问题：是否要将一个复杂的查询分成多个简单的查询。

#### 切分查询：分而治之的思路
隔一段时间删除10000条数据，一般来说是一个比较高效且对服务器影响也最小的办法。大大减少的删除时锁的持有时间。

#### 分解关联查询
有一些好处：
* 让缓存的效率更高，应用程序可以方便的缓存单表查询对应的结果对象
* 分解后单个查询减少锁的竞争
* 在应用层做关联
* 查询本身的效率也有所提升
* 减少冗余记录的查询
* 在应用中实现哈希关联而不是MySQL的嵌套关联

很多场景下通过重构查询将关联放到应用程序中将会更加的高效。

### 查询是怎么执行的？
![屏幕快照 2020-06-23 下午8.41.41.png](https://i.loli.net/2020/06/23/JSaHPiVThptQOzv.png)
1. 客户端发送查询
2. 检查缓存，命中立即返回
3. SQL解析、预处理，优化器生成对应的执行计划
4. 根据执行计划点用存储引擎的API进行查询
5. 返回给客户端

#### MySQL客户端/服务器端通信协议
半双工、没有办法进行流量控制。
查询状态：Sleep、Query、Locked、Analyzing and statistics、Copying to tmp table、Sorting result、Sending data

#### 查询缓存（名词）
如果查询缓存打开，MySQL优先检查这个查询是否命中。通过一个对于大小写敏感的哈希查找。命中后检查用户权限，如果权限够，不会解析查询，不生成执行计划，也不会执行。

#### 查询优化
1. 语法解析成语法树
2. 语法树被认为合法，转换成执行计划。一条查询可以有多种执行方式，都返回相同的结果，优化器作用就是找到其中最好的执行计划。
3. 通过因子的值来计算操作的代价

选择错误执行计划的原因：
* 统计信息不准确
* 估算可能不准确
* 此最优非彼最优，并不是最快的（听不懂）
* 不考虑并发执行的查询
* 不考虑存储过程和自定义函数
* 无法估算所有可能的执行计划

能够处理的优化类型（不是全部，但足以证明其复杂性和智能性）
* 重新定义关联表顺序
* 外链接转化成内链接
* 使用等价变换规则
* 优化COUNT、MIN、MAX
* 预估并转化为常数表达式
* 覆盖索引扫描
* 子查询优化
* 提前终止查询（使用了Limit、发现了不成立的条件）
* 等值传播
* 列表in的比较（MySQL使用IN时，先排序，在二分法进行判断）

MySQL是如何进行关联查询的？
* 每一次查询都是一次关联。
* MYSQL对于任何关联都执行嵌套关联操作。先从一个表里循环取出单条数据，在嵌套循环到下一个表中寻找匹配的行。
* 可以使用STRAIGHT——JOIN关键词重写查询，让优化器按照你个爹关联顺序执行，但是人的判断一般没有机器精确。

如何进行排序优化？
应该尽可能比秒排序或者尽可能避免对大量数据进行排序。
当需要排序的数据小雨排序缓冲区，使用内存进行快速排序。如果内存不够，则分块进行快排，再进行合并排序。

两种排序算法：
* 读取行指针和排序字段，排序之后更具结果读取数据行
* 读取所有列，根据列进行排序，返回排序结果

在关联查询时，如果需要进行排序，有两种情况：
* 如果order by来自第一个关联表，那么他在关联第一个表的时候就进行关联排序。`Extra：Using filesort`
* 此外所有情况，都先将关联的数据放在临时表中再进行排序。`Extra:Using temporary;Using filesort`如果还有limit，则将在排序之后执行limit

#### 查询执行引擎
MySQL只是简单地根据执行计划给出的指令逐步执行。过程中，大量的操作通过调用存储引擎借口来完成，‘Handler API’，查询中的每一个表都是由一个handler实例表示，在优化阶段就已经为每个表都创造了handler实例。

#### 返回结果给客户端
如果查询可以被缓存，那么MySQL在这个阶段也会将结果放置到查询缓存中。返回解雇哦好死一个增量、逐步返回的过程，服务器端无需存储太多的结果，也不会耗费太多内存。

### 查询优化器的局限性
#### 关联子查询可能有一些问题
关联子查询的性能比较差，但是不一定是最差的写法，有时候关联子查询是一种非常合理、自然甚至性能最好的写法。有时候EXSIT比关联更快。

#### UNION的限制
无法将限制条件从外层下推到内层，使得原本能够限制部分返回结果的条件无法应用到内层查询中，比如说对于整体查询进行limit,需要在内部也应用limit性能才更加的好。

#### 等值传递的问题
会增加一些意想不到的额外消耗。对于`IN()`列表，mysql优化器发现存在where on、 using 的子句使得这个列表的值和另一个表相关联。

#### 无法并行执行查询
如题，不支持。其他的关系型数据库支持。

#### 哈希关联
MySQL8 才支持哈希关联。

#### 松散索引扫描
MySQL不支持松散索引扫描，无法按照不连续的方式扫描一个索引。
什么是松散索引扫描？
![rqGsnvJYaAPe96E](https://i.loli.net/2020/06/24/rqGsnvJYaAPe96E.png)

#### 最大值和最小值优化
对于min()和max()，Mysql的优化做的不是很好。
```SQL
SELECT MIN(id) FROM actor WHERE first_name = "adfgg";
```
因为在`first_name`没有索引，因此会做一次全表扫描，如果它能够进行主键扫描，理论上当读到第一个满足条件的记录的时候，就是找的最小值，因为id字段是严格按照大小排序的。可以直接通过使用`LIMIT 1`来进行优化重写。

#### 同时查询和更新。
不允许对于同一张表同时进行查询和更新。


### 使用优化器提示来改变执行计划
可以查看官方有关Hint的要求。

### 优化特定类型的查询
#### 优化count()
MyISAM的count在没有where 条件的时候非常的快。
可以通过增加汇总表和外部缓存系统来优化count扫描。

#### 优化关联查询
* 确保`On`或者`Using` 子句中的列上有索引
* 确保`group by`和`order by`中的表达式只涉及一个表中的列，这样才能够使用索引来优化这个过程
* 注意版本

#### 优化子查询
尽可能用关联查询代替

#### 优化GROUP BY 和 DISTINCT
两者可以相互转化
将超级聚合`with rollup`这个做法放到应用层面

#### 优化limit
`limit 10000,20 `会将前面的都丢弃，代价非常高。
此时使用索引覆盖扫描，而不是查询所有的列，效率提升非常大。
同时可以记录上一次的条数，然后下一页查询从记录的开始，不管翻页到什么情况下，性能都很好。ß

#### 优化SQL_CALC_FOUND_ROWS
在`limit`语句中加入这个hint可以获得去掉limit以后满足条件的行数，作为分页的总数，这个情况下 进行了一次全表扫描，然后丢弃了不需要的，开销很大。

通过设计下一页按钮显示特定数量的记录。
或者缓存较多的数据。


#### 优化union查询
将`where` `limit` `order by`的条件放到内层可以使优化器对于这些条ß件进行优化。
如果不是一定要消除重复的行，那就一定要使用`UNION ALL`这样才不会对于整个临时表的数据做唯一性检查，这样的代价非常高。

#### 在使用自定义的变量时的局限
* 使用自定义变量，无法使用查询缓存
* 不能在使用常量或标示符的地方使用变量
* 只在一个连接中有效
* 在持久连接中会产生共享bug
* 5.0之前大小写敏感
* 不能显式声明自定义变量的类型，确定未定义的变量的具体类型的时机各个版本可能都不一样。是动态类型
* 优化器可能会把变量优化掉，会出现错误
* 赋值的顺序和时间并不是总是固定的
* 赋值符号`:=`优先级非常低，赋值表达式要用明确的括号
* 使用未定义的变量不会产生任何语法错误，非常容易犯错


## 新的特性
### 分区表

分区要做的事情就是以代价非常小的方式定位数据在哪一片。

分区的主要目的是将数据按照较粗的粒度放在不同的表中。相关的数据可以存放在一起，批量删除整个分区也更加的方便。
适用的场景：
* 表非常大，无法全部放在内存中；热点数据在表最后
* 更容易维护。适合批量删除和独立优化
* 分区表的数据可以分布在不同的物理设备上
* 避免特殊竞争，比如InnoDB的单个索引的互斥访问、ext3文件系统的inode锁竞争等
* 备份和恢复独立分区

一些限制：
* 一个表最多只能有1024个分区
* 分区表达式必须是整数、或者是返回整数的表达式
* 分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引都必须包含进来

#### 分区表原理
进行增删查改操作之前，分区层都会先打开并锁住所有底层表。

如果存储引擎能够自己实现行级锁，InnoDB就会在分区层释放对应表所，这个加和解锁的过程与普通InnoDB上的查询类似。

#### 分区表的类型
* 根据范围进行分区（如图）
* 根据键值分区，减少InnoDB的互斥量竞争
* 根据哈希分区
* 根据列表分区
* 根据函数分区，mod7返回周几，HASH(id DIV 1000000)

![partition by range](https://i.loli.net/2020/06/25/URsloHTqm3QOFkA.png)

#### 如何使用分区表
当数据量超大的时候，B-Tree索引就没有办法起作用了。除非是索引覆盖查询，否则数据库服务器需要根据索引扫描的结果回表，查询所有符合条件的记录，如果数据量极大，将产生大量随机I/O，数据库的响应时间将大到不可接受。此外，索引维护的代价非常的高。

保证大数据量可扩展性的两个策略：
* 全量扫描数据，不要任何索引
* 索引数据，分离热点，热点数据所在的分区可以使用缓存、使用索引

#### 分区表的问题
* NULL值会使分区过滤无效。当为NULL或者非法值的时候他们会被分到底一个分区。当第一个分区很大的时候，第一种策略代价非常大。5.5以后可以使用列来进行分区，而不是函数，改变了这个情况。
* 分区列和索引列不匹配会导致无法进行分区过滤（？P264）
* 选择分区的成本可能会很高
* 打开并锁住底层表的成本可能很高
* 维护分区成本可能很高（新增和删除分区很快，但是重组分区很慢，需要临时表参与其中）
* 分区存储引擎要一致
* 分区函数和表达式有限制
* 某些存储引擎不支持分区
* MyISAM不能使用LOAD INDEX INTO CACHE操作
  
#### 使用分区进行查询优化
在where条件中带入分区列，看似多余也要带上。而且要和分区函数中列的数据类型一样。

Explain Partition 可以观察是否执行了分区过滤。partition分区会显示他所要查询的分区。

#### 合并表
一种过时的技术。代表一个容器，里面包含了多个真实的表。

删除合并表不会对子表产生影响。删除子表的影响视操作系统而定。

### 视图
虚拟表，不存放任何的数据。视图和表在同一个命名空间。

MySQL支持嵌套定义视图。视图操作中，有合并算法和临时表算法。其中如果视图中包括GROUP BY、DISTINCT、任何聚合函数、UNION、子查询等只要无法在原表记录和视图记录中建立一一映射的场景中，都会用临时表算法生成视图。当然也可以强行使用临时表算法生成一个临时表。
![53bUmzCEMJw41tH](https://i.loli.net/2020/06/25/53bUmzCEMJw41tH.png)

#### 可更新视图
可以通过更新这个视图来更新视图涉及的相关表。如果视图定义中包含了GROUP BY、任何聚合函数、UNION或者其他的一些特殊情况，就不能被更新。任何使用临时表算法的视图都无法被更新。

#### 视图对性能的影响
* 重构schema可以使用视图确保应用代码不报错
* 实现基于列的权限控制
* 使用临时表算法实现的视图，在某些时候性能会很差
* 如果打算使用视图，需要比较详细的测试，不能盲目使用

#### 视图的限制
* 不支持物化视图（结果存放在表中，定期从原始表获取数据）
* 不支持视图中的索引
* 不会保存视图定义的原始SQL语句

### 外键约束
InnoDB是目前MySQL中唯一支持外键的内置存储引擎。

使用外键的成本在于每次修改数据时都要在另一张表中多执行一次查找操作。

如果想确保两个相关表始终有一致的数据，那么使用外键比在应用程序中检查一致性的性能要高得多。

如果只是使用外键做约束，那么通常在应用程序中实现约束会更好。

### 在MySQL内部存储代码（性能方面）
形式：触发器、存储过程、函数

优点：
* 服务器内部执行，节省带宽和网络延迟
* 代码重用
* 简化代码的维护和版本更新
* 提升安全、提供细粒度的权限控制
* 缓存存储过程的执行计划，大大降低功耗
* 存储过程维护工作很简单
* 各司其职可以交给数据库专家

缺点：
* 不太好调试
* 难以实现复杂逻辑
* 带来额外复杂性
* 安全性会被一举攻破
* 给数据库服务器增加额外的压力
* 无法控制存储过程的资源消耗
* 存储代码功能比较弱
* 和二进制日志合作的并不好

很多短小的查询使用存储过程代替可以减少网络通信开销、解析开销和优化器开销因而更加快速。

#### 触发器
MySQL中：
* 对于每一个表的每一个事件，只能定义一个触发器
* MySQL只支持**基于行的触发（最大性能限制）**，如果变更数据集很大，效率会很低。

对于触发器本身，有以下限制：
* 掩盖背后的工作
* 问题很难排查
* 可能导致死锁和锁等待

在实现约束、系统维护任务、更新反范式数据、记录数据变更日志时适合用触发器。

#### 事件
定时任务。可以在informatuob_schema.events中看到各个事件的状态。

### 游标

游标指向的对象都是存储在临时表而不是实际查询到的数据，总是只读的。

**案例没听懂P284**

### 绑定变量

![Xolyf8dDMisCptG](https://i.loli.net/2020/06/25/Xolyf8dDMisCptG.png)


