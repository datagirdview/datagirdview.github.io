---
layout: page
title: 高性能MySQL
---

## 架构
他的架构设计把**查询处理以及系统任务**和**数据的存储和提取**相分离。

![架构图](https://i.loli.net/2020/05/25/r4DdlefLk1gFtqY.png)

### 并发控制
通过创建锁，来控制并发的资源占用问题。
#### 读写锁
读锁，也叫共享锁，互相不阻塞。
写锁，也叫排他锁，会阻塞其他的读锁和写锁。
#### 锁粒度
通过区分加锁的数据量，来提升系统的并发量。但是锁操作都会增加系统的开销。所以要在安全性和锁开销之间寻求一个平衡。
##### 两种重要的锁策略
表锁：开销最小的策略。一般采用mysql自己实现的表锁而忽略存储引擎的锁机制。
行锁：最大程度的并发处理，伴随最大的开销。且只在存储引擎中实现。

### 事务
四大特性：
* 原子性：要么全部成功，要么全部失败
* 一致性：从一个一致性转换成另一种一致性
* 隔离性：所做的改变在最终提交之前，对于其他事务来说是不可见的
* 持久性：事务提交之后改动不会丢失

#### 四种隔离级别
较低级别的隔离通常可以执行更高的并发，开销也更低。
* read uncommitted（未提交读）：很少使用，问题很多
* read uncommitted（提交读/不可重复读）：大多数数据库系统的默认级别（Mysql不是），其他事务执行两次相同的读可能得到不一样的结果。
* repeatable read（可重复读）：MySQL默认隔离级别。解决脏读问题，会有幻行的问题（多了一行）。Mysql已经解决了这一问题。
* serializable（串行）：强制事务串行执行。对读取的所有行都加锁。

避免不可重复读锁行就行
避免幻读锁表就行

#### 多版本并发控制MVCC
行级锁的变种，很多情况下避免了加锁操作，开销更低。

InnoDB的MVCC通过在每一行后面保存两个隐藏的列来实现，一个是行的创建时间，一个是行的过期时间（版本号）

### 引擎
#### InnoDB
数据存储在表空间中。表是基于聚簇索引建立的。
#### MyISAM
不支持事务和行级锁，崩溃后无法恢复。

MYD和MYI文件存储，分别存储数据文件和索引文件。


## 服务器性能剖析
性能优化并不是降低cpu利用率、也不是提升每秒查询量
### 应用程序的性能剖析
对任何需要消耗时间的任务都可以进行性能剖析。性能瓶颈可能有很多的影响因素：
* 外部资源。调用了外部的服务或者搜索引擎
* 应用处理大量的数据，分析一个超大规模的XML文件
* 在循环中执行昂贵的操作，滥用正则表达式
* 使用了低效的算法

性能剖析会导致服务器变慢，但是为了定位一些性能平静下来，还是值得的，可以通过采样的方式发现严重问题。
### 关于MySQL的查询
#### 整体负载
**慢查询日志**
记录执行时间超过某一值的语句。是开销最低、精度最高的测量查询时间的工具。
分析慢查询日志时，先使用pt-query-digest生成一个剖析报告，它能够提供日志的一个整体的概览，接下来再去定为精确所在之处也不迟。
![pt-query-digest](https://i.loli.net/2020/05/28/eIOhlKNU8JgpwX5.png)

#### 单条查询优化
* `show profile`：服务器上执行的所有语句都会测量器耗费的时间
* `show status`：返回全局计数器，也有某个会话级别的计数器。显示某些活动的频繁程度。
* 慢查询日志
* `performance schema`：5.5之后会变得很强大，待考证。

#### 如何诊断间歇性问题
使用`show global status`/`show process list`/`查询日志`确定是单条查询还是服务器问题

## schema与数据类型的优化
### 优化的数据类型
#### 原则
* 更小的通常更好，但要确保没有低估值的范围
* 简单就好，整型比字符操作代价更低
* 尽量避免NULL值。但通常把可为NULL的列改为NOT NULL对性能提升不是很大，如果计划对该列上建立索引，那么最好不要设置NULL

在选择数据类型是，第一步确定合适的大类型（数字、字符串、时间等），然后选择具体的类型。

#### 整数类型
`TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`、`BIGINT`，也可以无符号，将上限提升一倍

分别是8,16,24,32,64为存储空间 $-2^{N-1}\leq x \leq 2^{N-1}$

#### 实数类型

`DECIMAL`类型可以指定精度，对于`DECIMAL`列可以指定小数点前后所允许的最大位数。`DECIMAL`(18,9)小数点两边各存储9个数字，一共使用9个字节，一个小数点，4个整数部分、4个小数部分。

`FLOAT`使用4个字节，`DOUBLE`使用8个字节。MySQL使用`DOUBLE`作为内部浮点计算的类型。

#### 字符串类型

`VARCHAR`、`CHAR`实现形式与数据库引擎有关。

`VARCHAR`用于存储可变长字符串，比定长更加节省空间，但update时可能需要做额外开销。`VARCHAR`需要使用1-2个额外字节记录字符的长度。

合适的情况：
* 列最大长度比平均长度大很多
* 列更新很少
* 使用了复杂的字符集UTF-8

`CHAR`适合存储很短的字符串，或者所有值接近同一个长度，并且删除所有的末尾空格。例如MD5值，因为定长的MD5值不容易产生碎片。

`BLOB`和`TEXT`，BLOB二进制、TEXT字符形式，BLOB和SMALLBLOB同义词，TEXT和SMALLTEXT同义词。当他们太大时，InnoDB会使用专门的存储区域来存储，在行内需要1-4个字节存储一个指针。

需要尽量避免使用这两种类型。

**使用枚举代替字符串**
* 存储非常紧凑，会根据列表值的数量压缩到1-2个字节中。将每个值在列表中的位置保存为整数，并且在frm的文件中保存数字-字符串映射关系的查找表。
* 内部排序按照枚举的存储顺序排序的。
* 字符列表是固定的，添加、删除都是需要使用`ALTER TABLE`的

#### 日期和时间类型

`DATETIME`：1001-9999精度为秒，YYYYMMDDHHMMSS

`TIMESTAMP`：1970-2038 秒数，比datetime的效率更高。

#### 位数据类型
`BIT`：存储一个或者多个True False的值（0，1的字符串）

如果存储一个`b'00111001'`的值，数字上下文的场景中，会导致返回57，而不是ascii码为57的字符‘9’，因此要谨慎使用BIT。
![屏幕快照 2020-05-30 下午4.59.25.png](https://i.loli.net/2020/05/30/l9qKUinm5ypakY6.png)

`SET`：一种代价相对来说较高的表示位的形式，一些列打包的bit位。但是改变列的代价相对较高，且无法在set列上通过索引查找。

#### 如何选定标识符

整数通常是最好的选择 很快，并且可以使用auto_increment

enum和set糟糕的选择

尽量避免使用字符作为标识列，当使用uuid值时，最好把“-”删除，按照数字的方式存储，还是不如递增的整数好用

一些ORM系统是常见的性能噩梦，存储的类型比较任意。

### schema设计中的陷阱

* 太多的列：行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的
* 太多的关联：单个查询最好在12个表以内做关联
* 全能的枚举：0，1，2，3
* 变相的枚举
* 非此发明的NULL：不要刻意不用NULL

### 范式和反范式

范式化的数据库中，每个事实数据都会出现并且仅出现一次。
反范式化的数据库中，信息是冗余的可能存储在多个地方。

#### 范式的优点和缺点
优点：

* 更新操作比反范式操作快
* 当数据较好的范式化时，就只有很少或者没有重复数据，所以执行操作会更快
* 范式化的表通常更小，可以更好的放在内存里，执行操作会更快
* 很少有多余的数据意味着检索列表时更少需要DISTINCT或者GROUP BY
  
缺点：
通常需要关联，代价昂贵，使得一些索引策略无效

#### 反范式的优点和缺点
优点：
* 避免关联
* 进行更有效的索引策略

#### 实际应用中经常是混用范式化和反范式化
最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列，可以使用触发器更新缓存值。

### 缓存表和汇总表
缓存表表示存储哪些可以比较简答的从schema中其他表中获取数据的表（获取的速度比较慢）
汇总表表示的是使用GROUP BY语句聚合数据的表

有时候可以在缓存表上使用别的数据库引擎，例如支持更小索引占用空间、全文搜索的MyISAM。

使用缓存表和汇总表时，要决定是定时维护还是定期重建数据。

重建汇总表和缓存表时，通常需要保证数据在操作时仍然可用，通过‘影子表’实现。

更快的读，更慢的写。

### 如何加快ALTER TABLE
有一些情况不需要重建表
* 移除一个列的AUTO_INCREMENT
* 增加、删除和更改enum set常量

技术是为想要的表结构创建一个新的.frm：
1. 创建一张有相同结构的空表，进行所需要的修改
2. FLUSH TABLES WITH READ LOCK，关闭所有表。
3. 交换frm文件
4. UNLOCK TABLES


## 创建高性能的索引
### 什么是索引
#### B-tree索引
* 支持全值匹配
* 匹配最左前缀
* 匹配列前缀
* 匹配范围值
* 匹配一列到另一列
* 只访问索引
#### 哈希索引
只有memory引擎支持hash索引
只能进行全值匹配
#### 空间数据索引
#### 全文索引
### 索引好在哪里
* 减少服务器需要扫描的数据量
* 帮助服务器避免排序和临时表
* 将随机IO变为顺序IO
  
注：当表比较小时，全表查找比索引可能更快，中大型表用索引，大型表建立索引开销比较大，可以采用分区索引。

### 高性能的索引策略
#### 选择独立的列
要求查询时，索引列既不能是表达式的一部分，也不能是函数的参数
#### 前缀索引
索引的选择性：不重复的索引值和数据表记录总数的比值，$[\frac{1}{n},n]$。
能够是索引更小更快的有效办法，无法进行orderby和groupby
#### 选择合适的索引策略
如果一个索引对应的数据条数更小，那么它应该放在更前面
#### 聚簇索引
数据放在叶子结点，索引在树节点上
InnoDB通过主键聚集数据，如果没有主键，则使用非空索引，如果没有索引，隐式定义一个主键作为聚簇索引。
#### 覆盖索引
索引中已经包含要查询的字段的值
如果视同like来做匹配，那么就不能进行覆盖索引
#### 使用索引扫描来做排序
* 只有当索引的列顺序和orderby的子句顺序完全一致并且所有列的排序方向都一样时，MySQL才能够使用索引来对结果做排序
* 关联操作时，只有子句引用字段全部为第一个表时，才能够使用索引做排序

满足最左前缀的要求
#### 压缩索引
MyISAM使用前缀压缩来减少索引的大小，从而让更多索引可以放入内存中。不过某些操作会更慢
```
ex:perform,performance
output:7,ance
```

#### 冗余和重复索引
mysql的唯一约束和主键都是索引实现的。多个在同一个字段上，就是重复索引。
`(A,B)`和`(A)`，后者就是冗余索引，`(B,A)`不是冗余索引

#### 未使用索引
建议删除

#### 索引和锁
Inno只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，减少锁的数量。

### 维护索引和表
通过`CHECK TABLE`来检查是否发生了表损坏，`REPAIRE TABLE`来修复表。如果不可以，可以使用`ALTER TABLE innodb_tb1 ENGINE=INNODB;`

## 查询性能优化
查询优化、索引优化、库表结构必须要齐头并进
### 查询速度慢的原因
查询的生命周期：从客户端、到服务器，服务器解析、生成执行计划，执行、返回结果给客户端。执行是生命周期中最重要的阶段，也是最耗时的步骤。
在执行中，查询需要在不同的地方花费时间，包括网络、cpu计算、生成统计信息和执行计划、锁等待操作等。

### 访问的数据太多：优化数据访问
分析是否试一下的两个问题：
#### 是不是在检索超多数据，访问了太多的行，或者是列
* 查询了不需要的数据，比如客户端只需要前十行
* 多标关联时返回了全部列
* 总是取出全部列（一些DBA是禁止`select * `写法的）
* 重复查询相同的数据
#### 是不是在扫描额外的记录
* 估计响应时间（我不太会）
* 查看扫描的行数。能够说明该查询的效率
* 查看访问类型。`EXPLAIN`语句中的`type`能够反映访问类型，访问类型的种类为全表扫描、索引扫描、范围扫描、唯一索引扫描、常数引用等。速度由快到慢。

一般MySQL能够使用如下方式应用WHERE条件（由好到坏）：
* 在索引中使用WHERE条件来过滤不匹配的记录，在存储引擎层完成。
* 使用索引覆盖扫描（Extra：Using Index）来返回记录，从索引中过滤不需要的记录并返回命中的结果，无需回表查询。
* 从数据表中返回数据，过滤不满足条件的记录。

一些技巧：
* 使用索引覆盖扫描，将需要的列都放在索引中
* 改变库表结构。例如使用单独的汇总表
* 充血复杂查询，让MySQL优化器能够以更加优化的方式执行这个查询

### 重构查询的方式
一个重要的问题：是否要将一个复杂的查询分成多个简单的查询。

#### 切分查询：分而治之的思路
隔一段时间删除10000条数据，一般来说是一个比较高效且对服务器影响也最小的办法。大大减少的删除时锁的持有时间。

#### 分解关联查询
有一些好处：
* 让缓存的效率更高，应用程序可以方便的缓存单表查询对应的结果对象
* 分解后单个查询减少锁的竞争
* 在应用层做关联
* 查询本身的效率也有所提升
* 减少冗余记录的查询
* 在应用中实现哈希关联而不是MySQL的嵌套关联

很多场景下通过重构查询将关联放到应用程序中将会更加的高效。

### 查询是怎么执行的？
![屏幕快照 2020-06-23 下午8.41.41.png](https://i.loli.net/2020/06/23/JSaHPiVThptQOzv.png)
1. 客户端发送查询
2. 检查缓存，命中立即返回
3. SQL解析、预处理，优化器生成对应的执行计划
4. 根据执行计划点用存储引擎的API进行查询
5. 返回给客户端

#### MySQL客户端/服务器端通信协议
半双工、没有办法进行流量控制。
查询状态：Sleep、Query、Locked、Analyzing and statistics、Copying to tmp table、Sorting result、Sending data

#### 查询缓存（名词）
如果查询缓存打开，MySQL优先检查这个查询是否命中。通过一个对于大小写敏感的哈希查找。命中后检查用户权限，如果权限够，不会解析查询，不生成执行计划，也不会执行。

#### 查询优化
1. 语法解析成语法树
2. 语法树被认为合法，转换成执行计划。一条查询可以有多种执行方式，都返回相同的结果，优化器作用就是找到其中最好的执行计划。
3. 通过因子的值来计算操作的代价

选择错误执行计划的原因：
* 统计信息不准确
* 估算可能不准确
* 此最优非彼最优，并不是最快的（听不懂）
* 不考虑并发执行的查询
* 不考虑存储过程和自定义函数
* 无法估算所有可能的执行计划

能够处理的优化类型（不是全部，但足以证明其复杂性和智能性）
* 重新定义关联表顺序
* 外链接转化成内链接
* 使用等价变换规则
* 优化COUNT、MIN、MAX
* 预估并转化为常数表达式
* 覆盖索引扫描
* 子查询优化
* 提前终止查询（使用了Limit、发现了不成立的条件）
* 等值传播
* 列表in的比较（MySQL使用IN时，先排序，在二分法进行判断）

MySQL是如何进行关联查询的？
* 每一次查询都是一次关联。
* MYSQL对于任何关联都执行嵌套关联操作。先从一个表里循环取出单条数据，在嵌套循环到下一个表中寻找匹配的行。
* 可以使用STRAIGHT——JOIN关键词重写查询，让优化器按照你个爹关联顺序执行，但是人的判断一般没有机器精确。

如何进行排序优化？
应该尽可能比秒排序或者尽可能避免对大量数据进行排序。
当需要排序的数据小雨排序缓冲区，使用内存进行快速排序。如果内存不够，则分块进行快排，再进行合并排序。

两种排序算法：
* 读取行指针和排序字段，排序之后更具结果读取数据行
* 读取所有列，根据列进行排序，返回排序结果

在关联查询时，如果需要进行排序，有两种情况：
* 如果order by来自第一个关联表，那么他在关联第一个表的时候就进行关联排序。`Extra：Using filesort`
* 此外所有情况，都先将关联的数据放在临时表中再进行排序。`Extra:Using temporary;Using filesort`如果还有limit，则将在排序之后执行limit

#### 查询执行引擎
MySQL只是简单地根据执行计划给出的指令逐步执行。过程中，大量的操作通过调用存储引擎借口来完成，‘Handler API’，查询中的每一个表都是由一个handler实例表示，在优化阶段就已经为每个表都创造了handler实例。

#### 返回结果给客户端
如果查询可以被缓存，那么MySQL在这个阶段也会将结果放置到查询缓存中。返回解雇哦好死一个增量、逐步返回的过程，服务器端无需存储太多的结果，也不会耗费太多内存。

### 查询优化器的局限性

李做雕