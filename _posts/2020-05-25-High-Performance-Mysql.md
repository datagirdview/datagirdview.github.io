---
layout: page
title: 高性能MySQL
---

## 架构
他的架构设计把**查询处理以及系统任务**和**数据的存储和提取**相分离。

![架构图](https://i.loli.net/2020/05/25/r4DdlefLk1gFtqY.png)

### 并发控制
通过创建锁，来控制并发的资源占用问题。
#### 读写锁
读锁，也叫共享锁，互相不阻塞。
写锁，也叫排他锁，会阻塞其他的读锁和写锁。
#### 锁粒度
通过区分加锁的数据量，来提升系统的并发量。但是锁操作都会增加系统的开销。所以要在安全性和锁开销之间寻求一个平衡。
##### 两种重要的锁策略
表锁：开销最小的策略。一般采用mysql自己实现的表锁而忽略存储引擎的锁机制。
行锁：最大程度的并发处理，伴随最大的开销。且只在存储引擎中实现。

### 事务
四大特性：
* 原子性：要么全部成功，要么全部失败
* 一致性：从一个一致性转换成另一种一致性
* 隔离性：所做的改变在最终提交之前，对于其他事务来说是不可见的
* 持久性：事务提交之后改动不会丢失

#### 四种隔离级别
较低级别的隔离通常可以执行更高的并发，开销也更低。
* read uncommitted（未提交读）：很少使用，问题很多
* read uncommitted（提交读/不可重复读）：大多数数据库系统的默认级别（Mysql不是），其他事务执行两次相同的读可能得到不一样的结果。
* repeatable read（可重复读）：MySQL默认隔离级别。解决脏读问题，会有幻行的问题（多了一行）。Mysql已经解决了这一问题。
* serializable（串行）：强制事务串行执行。对读取的所有行都加锁。

避免不可重复读锁行就行
避免幻读锁表就行

#### 多版本并发控制MVCC
行级锁的变种，很多情况下避免了加锁操作，开销更低。

InnoDB的MVCC通过在每一行后面保存两个隐藏的列来实现，一个是行的创建时间，一个是行的过期时间（版本号）

### 引擎
#### InnoDB
数据存储在表空间中。表是基于聚簇索引建立的。
#### MyISAM
不支持事务和行级锁，崩溃后无法恢复。

MYD和MYI文件存储，分别存储数据文件和索引文件。


